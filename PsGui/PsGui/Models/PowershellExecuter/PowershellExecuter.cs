using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Management.Automation;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Data;
using System.Windows.Forms;

namespace PsGui.Models.PowershellExecuter
    {
    /// <summary>
    /// A class responsible for executing a powershell 
    /// script at a provided path with provided arguments.
    /// </summary>
    class PowershellExecuter
        {
        private List<string> commandLineArguments;
        private List<string> commandLineArgKeys;

        /// <summary>
        /// Gets the script execution output.
        /// </summary>
        public string ScriptOutput { get; private set; }

        /// <summary>
        /// Gets or sets the script execution error messages.
        /// </summary>
        public string ScriptErrors { get; private set; }

        /// <summary>
        /// Collects and saves error messages generated by the
        /// powershell script instance.
        /// </summary>
        /// <param name="instance"></param>
        private void CollectPowershellScriptErrors(PowerShell instance)
            {
            if (instance.HadErrors)
                {
                StringBuilder tmp = new StringBuilder();
                foreach (ErrorRecord err in instance.Streams.Error)
                    {
                    tmp.Append("**General message**");
                    tmp.Append('\n' + err.ToString());
                    tmp.Append("\n\n**Fully Qualified Error ID**");
                    tmp.Append('\n' + err.FullyQualifiedErrorId.ToString());
                    tmp.Append("\n\n**Stack trace**");
                    tmp.Append('\n' + err.ScriptStackTrace.ToString());
                    tmp.Append('\n' + "------------------------------\n\n");
                    }
                ScriptErrors = tmp.ToString();
                }
            else
                {
                // If a previous script has generated errors
                // But a new script does not generate errors
                // Then remove the previously recorded error
                if(ScriptErrors != null && ScriptErrors.Length > 0)
                    {
                    ScriptErrors = "";
                    }
                }
            }

        /// <summary>
        /// Collects and saves the output generated by the
        /// powershell script instance.
        /// </summary>
        /// <param name="instance"></param>
        private void CollectPowershellScriptoutput(Collection<PSObject> instanceOutput)
            {
            StringBuilder tmp = new StringBuilder();
            foreach (PSObject output in instanceOutput)
                {
                if (output != null)
                    {
                    tmp.Append(output.ToString());
                    }
                }
            ScriptOutput = tmp.ToString();
            }

        /// <summary>
        /// Gets the script argument data from the supplied composite collection
        /// consisting of multiple collection containers consisting of 
        /// observable objects.
        /// </summary>
        /// <param name="scriptVariables"></param>
        private void GetScriptParameters(CompositeCollection scriptVariables)
            {
            foreach(CollectionContainer collection in scriptVariables)
                {
                foreach(ScriptArgument arg in collection.Collection)
                    {
                    string argKey = arg.InputKey.ToString().ToLower();
                    string argValue = arg.InputValue.ToString();
                    commandLineArgKeys.Add(argKey);
                    commandLineArguments.Add(argValue);
                    }
                }
            }

        /// <summary>
        /// Executes the powershell script in the provided
        /// file path. Calls functions responsible to collect output.
        /// </summary>
        /// <param name="scriptPath"></param>
        public void ExecuteScriptCommands(string scriptPath)
            {
            using (PowerShell psInstance = PowerShell.Create())
                {
                psInstance.AddCommand(scriptPath);
                int argLength = commandLineArguments.Count;
                for (int ii = 0; ii < argLength; ii++)
                    {
                    psInstance.AddParameter(commandLineArgKeys[ii], commandLineArguments[ii]);
                    }
                
                // Prevents displaying objects as objects
                psInstance.AddCommand("Out-String");

                Collection<PSObject> psOutput = psInstance.Invoke();

                CollectPowershellScriptoutput(psOutput);
                CollectPowershellScriptErrors(psInstance);
                }
            }
        
        /// <summary>
        /// Constructor
        /// </summary>
        public PowershellExecuter()
            {
            ScriptOutput         = "";
            commandLineArguments = new List<string>();
            commandLineArgKeys   = new List<string>();
            }

        /// <summary>
        /// Executes the powershell script at the provided file path
        /// with the provided Composite collection consiting of the
        /// different types of input values.
        /// </summary>
        /// <param name="scriptPath"></param>
        /// <param name="scriptVars"></param>

        public void ExecuteScript(string scriptPath, CompositeCollection scriptVars)
            {
            GetScriptParameters(scriptVars);
            ExecuteScriptCommands(scriptPath);
            }

        public void ExecuteScriptAsync(string scriptPath, CompositeCollection scriptVars)
        {
            GetScriptParameters(scriptVars);
            ExecuteScriptCommandsAsync(scriptPath);
        }

        public void wait(int milliseconds)
        {
            System.Windows.Forms.Timer timer1 = new System.Windows.Forms.Timer();
            if (milliseconds == 0 || milliseconds < 0) return;
            //Console.WriteLine("start wait timer");
            timer1.Interval = milliseconds;
            timer1.Enabled = true;
            timer1.Start();
            timer1.Tick += (s, e) =>
            {
                timer1.Enabled = false;
                timer1.Stop();
                //Console.WriteLine("stop wait timer");
            };
            while (timer1.Enabled)
            {
                System.Windows.Forms.Application.DoEvents();
            }
        }

        public async Task ExecuteScriptCommandsAsync(string scriptPath)
        {
            using (PowerShell psInstance = PowerShell.Create())
            {
                psInstance.AddScript(scriptPath);
                PSDataCollection<PSObject> outputCollection = new PSDataCollection<PSObject>();

                // Collect output in real time
                outputCollection.DataAdded += outputCollection_DataAdded;
                psInstance.Streams.Error.DataAdded += Error_DataAdded;

                IAsyncResult result = psInstance.BeginInvoke<PSObject, PSObject>(null, outputCollection);

                // When wrapping PowerShell instance in a using block, the pipeline will
                // close and the script execution will abort. Therefore we must wait for
                // the state of the pipeline to equal Completed
                while (result.IsCompleted == false)
                {
                    Thread.Sleep(1000);
                }

                foreach (PSObject outputItem in outputCollection)
                {
                    ScriptOutput += outputItem.ToString();
                }
            }
        }

        /// <summary>
        /// Event handler for when data is added to the output stream.
        /// </summary>
        /// <param name="sender">Contains the complete PSDataCollection of all output items.</param>
        /// <param name="e">Contains the index ID of the added collection item and the ID of the PowerShell instance this event belongs to.</param>
        void outputCollection_DataAdded(object sender, DataAddedEventArgs e)
        {
            ScriptOutput += sender.ToString();
            System.Windows.MessageBox.Show(sender.ToString());
        }

        /// <summary>
        /// Event handler for when Data is added to the Error stream.
        /// </summary>
        /// <param name="sender">Contains the complete PSDataCollection of all error output items.</param>
        /// <param name="e">Contains the index ID of the added collection item and the ID of the PowerShell instance this event belongs to.</param>
        void Error_DataAdded(object sender, DataAddedEventArgs e)
        {
            // do something when an error is written to the error stream
            Console.WriteLine("An error was written to the Error stream!");
        }


        /// <summary>
        /// Clears the script output.
        /// </summary>
        public void ClearScriptOutput()
            {
            ScriptOutput = "";
            }

        /// <summary>
        /// Clears stored data, excludes the scriptoutput.
        /// </summary>
        public void ClearSession()
            {
            commandLineArgKeys.Clear();
            commandLineArguments.Clear();
            }
        }
    }
