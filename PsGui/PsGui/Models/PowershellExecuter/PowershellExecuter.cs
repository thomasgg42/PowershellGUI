using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Management.Automation;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Data;
using System.Windows.Forms;

namespace PsGui.Models.PowershellExecuter
    {
    /// <summary>
    /// A class responsible for executing a powershell 
    /// script at a provided path with provided arguments.
    /// </summary>
    class PowershellExecuter
        {
        private List<string> _commandLineArguments;
        private List<string> _commandLineArgKeys;

        /// <summary>
        /// Constructor
        /// </summary>
        public PowershellExecuter()
        {
          //  ScriptOutput = "";
            CommandLineArguments        = new List<string>();
            CommandLineArgumentKeys     = new List<string>();
            ScriptExecutionOutputCustom = new ObservableCollection<CustomOutput>();
        }

        public string CustomOutputPrefix                         { get; } = "cust: ";
      //  public string ScriptExecutionOutput                      { get; set; }
        public string ScriptExecutionOutputRaw                   { get; set; }
    //    public string ScriptExecutionErrorCustom                 { get; set; }
        public string ScriptExecutionErrorRaw                    { get; set; }
        public string ScriptExecutionErrorException              { get; set; }
        public string ScriptExecutionErrorDetails                { get; set; }
        public string ScriptExecutionErrorCategoryInfo           { get; set; }
        public string ScriptExecutionErrorFullyQualifiedErrorId  { get; set; }
        public string ScriptExecutionErrorInvocationInfo         { get; set; }
        public string ScriptExecutionErrorPipelineIterationInfo  { get; set; }
        public string ScriptExecutionErrorScriptStackTrace       { get; set; }
        public string ScriptExecutionErrorTargetObject           { get; set; }
        public string ScriptExecutionProgressPercentComplete     { get; set; }
        public string ScriptExecutionProgressCurrentOperation    { get; set; }

        public ObservableCollection<CustomOutput> ScriptExecutionOutputCustom { get; set; }

        // public string ScriptOutput                               { get; private set; }
        // public string ScriptErrors                               { get; private set; }


        /// <summary>
        /// Sets or gets a collection of command line argument keys
        /// required for the current PowerShell-script.
        /// </summary>
        public List<string> CommandLineArgumentKeys
        {
            get
            {
                return _commandLineArgKeys;
            }
            set
            {
                if(value != null)
                {
                    _commandLineArgKeys = value;
                }
            }
        }

        /// <summary>
        /// Sets or gets a collection of command line arguments
        /// required for the current PowerShell-script.
        /// </summary>
        public List<string> CommandLineArguments
        {
            get
            {
                return _commandLineArguments;
            }
            set
            {
                if(value != null)
                {
                    _commandLineArguments = value;
                }
            }
        }

        /// <summary>
        /// Collects and saves error messages generated by the
        /// powershell script instance.
        /// </summary>
        /// <param name="instance"></param>
    /*    public void CollectPowershellScriptErrors(PowerShell instance)
            {
            if (instance.HadErrors)
                {
                StringBuilder tmp = new StringBuilder();
                foreach (ErrorRecord err in instance.Streams.Error)
                    {
                    tmp.Append("**General message**");
                    tmp.Append('\n' + err.ToString());
                    tmp.Append("\n\n**Fully Qualified Error ID**");
                    tmp.Append('\n' + err.FullyQualifiedErrorId.ToString());
                    tmp.Append("\n\n**Stack trace**");
                    tmp.Append('\n' + err.ScriptStackTrace.ToString());
                    tmp.Append('\n' + "------------------------------\n\n");
                    }
               // ScriptErrors = tmp.ToString();
                }
            else
                {
                // If a previous script has generated errors
                // But a new script does not generate errors
                // Then remove the previously recorded error
                if(ScriptErrors != null && ScriptErrors.Length > 0)
                    {
                    ScriptErrors = "";
                    }
                }
            }
        */

        /// <summary>
        /// Collects and saves the output generated by the
        /// powershell script instance.
        /// </summary>
        /// <param name="instance"></param>
        public void CollectPowershellScriptOutput(Collection<PSObject> instanceOutput)
            {
            StringBuilder tmp = new StringBuilder();
            foreach (PSObject output in instanceOutput)
                {
                if (output != null)
                    {
                    tmp.Append(output.ToString());
                    }
                }
         //   ScriptOutput = tmp.ToString();
            }

        /// <summary>
        /// Executes the powershell script in the provided
        /// file path. Calls functions responsible to collect output.
        /// </summary>
        /// <param name="scriptPath"></param>
        public void ExecuteScriptCommands(string scriptPath)
            {
            using (PowerShell psInstance = PowerShell.Create())
                  {
                 psInstance.AddScript(scriptPath);
                  int argLength = CommandLineArguments.Count;
                  for (int ii = 0; ii < argLength; ii++)
                      {
                      psInstance.AddParameter(CommandLineArgumentKeys[ii], CommandLineArguments[ii]);
                      }

                  // Prevents displaying objects as objects
                  psInstance.AddScript("Out-String");

                  Collection<PSObject> psOutput = psInstance.Invoke();

                  CollectPowershellScriptOutput(psOutput);
             //     CollectPowershellScriptErrors(psInstance);
                  }
            }

        /// <summary>
        /// Sets the script argument data from the supplied composite collection
        /// consisting of multiple collection containers consisting of 
        /// observable objects.
        /// </summary>
        /// <param name="scriptVariables"></param>
        public void SetScriptParameters(CompositeCollection scriptVariables)
        {
            foreach (CollectionContainer collection in scriptVariables)
            {
                foreach (ScriptArgument arg in collection.Collection)
                {
                    string argKey = arg.InputKey.ToString().ToLower();
                    string argValue = arg.InputValue.ToString();
                    CommandLineArgumentKeys.Add(argKey);
                    CommandLineArguments.Add(argValue);
                }
            }
        }

        /// <summary>
        /// Executes the powershell script at the provided file path
        /// with the provided Composite collection consiting of the
        /// different types of input values.
        /// </summary>
        /// <param name="scriptPath"></param>
        /// <param name="scriptVars"></param>
        public void ExecuteScript(string scriptPath, CompositeCollection scriptVars)
            {
            SetScriptParameters(scriptVars);
            ExecuteScriptCommands(scriptPath);
            }

        /// <summary>
        /// Clears the script output.
        /// </summary>
        public void ClearScriptOutput()
            {
         //   ScriptOutput = "";
            }

        /// <summary>
        /// Clears stored data, excludes the scriptoutput.
        /// </summary>
        public void ClearSession()
            {
            CommandLineArgumentKeys.Clear();
            CommandLineArguments.Clear();
            }
        }
    }
